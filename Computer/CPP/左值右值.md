左值 && 右值
出现在等号“=”左边的就是左值，出现在等号“=”右边的就是右值。-----这是对左值和左值不严谨，但是很形象生动的说法。
在C++中广泛认同的是：可以取地址，有名字的是左值；不可以取地址，没有名字的是右值。
C++ 11中的右值由两个概念组成：将亡值（expire value），纯右值（pure Rvalue）:

纯右值
临时变量和一些跟对象不相关的值。例如：函数返回的非引用的临时变量；一些运算表达式（1+2）产生临时变量值；跟对象不相关的字面值：2， true；此外类型转换函数返回值，lambda表达式也是纯右值。

将亡值
将亡值C++11新增加跟右值引用相关的表达式。这样的表达式通常是将要被移动的对象。例如：返回右值引用T&& 的函数返回值，std::move()的返回值，转换为T&&的类型转换函数的返回值。

除了将亡值，纯右值以外的，都是左值。
事实上，左值和右值很难归纳出真正的定义，这里只是其判断方法。

右值引用（T&&）和左值引用（T&）都是引用类型，申明的时候就必须初始化。两种引用都是变量的一个别名，左值引用是有变量名的变量值的别名；右值引用是没有变量名的变量值的别名。

左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束时就不再存在的临时对象。所有的具名变量或者对象都是左值，而右值不具名。很难得到左值和右值的真正定义，但是有一个可以区分左值和右值的便捷方法：看能不能对表达式取地址，如果能，则为左值，否则为右值。

c++11中的所有容器都实现了move语义，move只是转移了资源的控制权，本质上是将左值强制转化为右值使用，以用于移动拷贝或赋值，避免对含有资源的对象发生无谓的拷贝。move对于拥有如内存、文件句柄等资源的成员的对象有效，如果是一些基本类型，如int和char[10]数组等，如果使用move，仍会发生拷贝（因为没有对应的移动构造函数），所以说move对含有资源的对象说更有意义

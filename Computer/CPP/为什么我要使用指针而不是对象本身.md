Why should I use a pointer rather than the object itself?
我来自Java背景，已经开始使用C++中的对象。但我想到的一件事是，人们经常使用指向对象的指针，而不是对象本身的指针，例如此声明：

~~~cpp
Object *myObject = new Object;
~~~
而不是：
~~~cpp
Object myObject;
~~~
或者不使用函数，比如说testFunc()，如下所示：
~~~cpp
myObject.testFunc();
~~~
我们必须写：
~~~cpp
myObject->testFunc();
~~~
但我不明白我们为什么要这样做。我假设这与效率和速度有关，因为我们可以直接访问内存地址。我说的对吗？


# 一、
很不幸，您经常看到动态分配。这只是显示有多少坏C++程序员有。好的。

从某种意义上讲，您有两个问题捆绑在一起。第一个问题是什么时候应该使用动态分配(使用new)？第二个问题是我们什么时候应该使用指针？好的。

重要的"带回家"信息是，您应该始终为工作使用适当的工具。在几乎所有情况下，都有比执行手动动态分配和/或使用原始指针更合适和更安全的方法。好的。动态分配

在您的问题中，您演示了两种创建对象的方法。主要区别在于对象的存储时间。当在一个块内执行Object myObject;操作时，对象是以自动存储持续时间创建的，这意味着当它超出范围时，它将被自动销毁。当您执行new Object()操作时，对象具有动态存储持续时间，这意味着它在显式delete之前保持活动。只有在需要时才应使用动态存储持续时间。也就是说，如果可以的话，您应该总是更喜欢创建具有自动存储持续时间的对象。好的。

可能需要动态分配的主要两种情况：
+ 您需要这个对象比当前作用域更长寿——这个特定的对象在那个特定的内存位置，而不是它的一个副本。如果您可以复制/移动对象(大多数情况下您应该是)，您应该更喜欢自动对象。
+ 您需要分配大量的内存，这很容易填满堆栈。如果我们不必担心这个问题(大部分时间你不必)，那将是很好的，因为它实际上是在C++的权限之外，但不幸的是，我们必须处理我们正在开发的系统的实际情况。

当您确实需要动态分配时，应该将其封装在智能指针或执行RAII的其他类型(如标准容器)中。智能指针提供动态分配对象的所有权语义。例如，看看std::unique_ptr和std::shared_ptr。如果使用得当，几乎可以完全避免执行自己的内存管理(参见零规则)。好的。指针

但是，除了动态分配之外，原始指针还有其他更一般的用途，但是大多数都有您应该选择的替代方法。和以前一样，除非你真的需要指针，否则总是选择其他选项。

+ 您需要引用语义。有时，您希望使用指针传递一个对象(不管它是如何分配的)，因为您希望传递给它的函数能够访问该特定对象(而不是它的副本)。然而，在大多数情况下，您应该更喜欢引用类型而不是指针，因为这是专门为它们设计的。注意，这不一定是关于将对象的寿命延长到当前范围之外，如上面的情况1所示。和以前一样，如果您可以传递对象的副本，就不需要引用语义。好的。

+ 你需要多态性。只能通过指向对象的指针或引用以多态方式调用函数(即根据对象的动态类型)。如果这是您需要的行为，那么您需要使用指针或引用。同样，应首选参考文献。好的。

+ 您希望通过允许在省略对象时传递nullptr来表示对象是可选的。如果它是一个参数，您应该更喜欢使用默认参数或函数重载。否则，您应该更喜欢使用封装此行为的类型，例如EDCOX1 OR 7(在C++ 17中引入的——具有较早的C++标准，使用EDCOX1 8)。好的。

+ 您希望分离编译单元以提高编译时间。指针的有用属性是，您只需要指向类型的前向声明(要实际使用对象，需要定义)。这允许您分离编译过程的各个部分，这可以显著地缩短编译时间。参见pimpl习惯用法。好的。

+ 您需要与C库或C样式库接口。此时，您必须使用原始指针。你能做的最好的事情就是确保你只在最后可能的时刻放松你的原始指针。例如，可以使用其get成员函数从智能指针获取原始指针。如果库为您执行某些分配，它希望您通过句柄解除分配，则通常可以使用自定义删除程序将句柄包装在智能指针中，该删除程序将适当地解除分配对象。

# 二、

指针有许多用例。

## 多态行为。对于多态类型，指针(或引用)用于避免切片：
~~~cpp
class Base { ... };
class Derived : public Base { ... };

void fun(Base b) { ... }
void gun(Base* b) { ... }
void hun(Base& b) { ... }

Derived d;
fun(d);    // oops, all Derived parts silently"sliced" off
gun(&d);   // OK, a Derived object IS-A Base object
hun(d);    // also OK, reference also doesn't slice
~~~

## 引用语义和避免复制。对于非多态类型，指针(或引用)将避免复制可能昂贵的对象。
~~~cpp
Base b;
fun(b);  // copies b, potentially expensive
gun(&b); // takes a pointer to b, no copying
hun(b);  // regular syntax, behaves as a pointer
~~~
请注意，C++ 11具有移动语义，可以避免将昂贵对象的许多副本转换为函数参数和返回值。但是使用指针肯定会避免这些情况，并且允许同一对象上有多个指针(而一个对象只能从一次移动)。

# 资源获取。使用EDCOX1的9位操作符创建一个资源指针是现代C++中的一种反模式。使用特殊资源类(标准容器之一)或智能指针(std::unique_ptr<>或std::shared_ptr<>)。考虑：
~~~cpp
{
    auto b = new Base;
    ...       // oops, if an exception is thrown, destructor not called!
    delete b;
}
~~~
VS
~~~cpp
{
    auto b = std::make_unique<Base>();
    ...       // OK, now exception safe
}
~~~
原始指针只能用作"视图"，而不应以任何方式涉及所有权，无论是通过直接创建还是通过返回值隐式创建。也请参阅来自C++ FAQ的这个问答。

每次复制共享指针(例如，作为函数参数)时，它所指向的资源都保持活动状态，从而实现更细粒度的生命周期控制。当超出范围时，常规对象(不是由new创建的，或者直接由您创建的，或者在资源类中创建的)会被销毁。
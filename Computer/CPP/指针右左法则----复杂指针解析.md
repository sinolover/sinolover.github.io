# 指针右左法则----复杂指针解析


其实如果写得出（其实不难）指针和数组的声明的EBNF的话，那么直接看就可以反应过来了……
## 左右法则定义
**右左法则**是一个既著名又常用的方法。不过，右左法则其实并不是C标准里面的内容，它是从C标准的声明规定中归纳出来的方法。C标准的声明规则，是用来解决如何创建声明的，而右左法则是用来解决如何辩识一个声明的，两者可以说是相反的。右左法则的英文原文是这样说的：
> The right-left rule: Start reading the declaration from the innermost parentheses, go right, and then go left. When you encounter parentheses, the direction should be reversed. Once everything in the parentheses has been parsed, jump out of it. Continue till the whole declaration has been parsed.
**这段英文的翻译如下：**
右左法则：首先从最里面的圆括号看起，然后往右看，再往左看。每当遇到圆括号时，就应该掉转阅读方向。一旦解析完圆括号里面所有的东西，就跳出圆括号。重复这个过程直到整个声明解析完毕。

笔者要对这个法则进行一个小小的修正，应该是从**左**起**第一个未定义的标识符**开始阅读，而不是从括号读起，之所以是未定义的标识符，是因为一个声明里面可能有多个标识符，但**未定义**的标识符**有且仅有一个**。

## 左右法则分析案例
现在通过一些例子来讨论右左法则的应用，先从最简单的开始，逐步加深：

~~~ cpp
int (*func)(int *p);
~~~
首先找到那个未定义的标识符，就是func，它的外面有一对圆括号，而且左边是一个\*号，这说明func是一个指针，然后跳出这个圆括号，先看右边，也是一个圆括号，这说明(\*func)是一个函数，而func是一个指向这类函数的指针，就是一个函数指针，这类函数具有int\*类型的形参，返回值类型是int。

~~~ cpp
int (*func)(int *p, int (*f)(int*));
~~~
func被一对括号包含，且左边有一个\*号，说明func是一个指针，跳出括号，右边也有个括号，那么func是一个指向函数的指针，这类函数具有```int *和int (*)(int*)``这样的形参，返回值为int类型。再来看一看func的形参``int (*f)(int*)``，类似前面的解释，f也是一个函数指针，指向的函数具有int*类型的形参，返回值为int。

``int (*func[5])(int *p);``
func右边是一个\[\]运算符，说明func是一个具有5个元素的数组，func的左边有一个\*，说明func的元素是指针，要注意这里的\*不是修饰func的，而是修饰func\[5\]的，原因是\[\]运算符优先级比\*高，func先跟[]结合，因此\*修饰的是func\[5\]。跳出这个括号，看右边，也是一对圆括号，说明func数组的元素是函数类型的指针，它所指向的函数具有int\*类型的形参，返回值类型为int。

~~~ cpp
int (*(*func)[5])(int *p);
~~~
func被一个圆括号包含，左边又有一个\*，那么func是一个指针，跳出括号，右边是一个\[\]运算符号，说明func是一个指向数组的指针，现在往左看，左边有一个\*号，说明这个数组的元素是指针，再跳出括号，右边又有一个括号，说明这个数组的元素是指向函数的指针。总结一下，就是：func是一个指向数组的指针，这个数组的元素是函数指针，这些指针指向具有int\*形参，返回值为int类型的函数。

~~~ cpp
int (*(*func)(int *p))[5];
~~~
func是一个函数指针，这类函数具有int\*类型的形参，返回值是指向数组的指针，所指向的数组的元素是具有5个int元素的数组。
要注意有些复杂指针声明是非法的，例如：

~~~cpp
int func(void) [5];
~~~
func是一个返回值为具有5个int元素的数组的函数。但C语言的函数返回值不能为数组，这是因为如果允许函数返回值为数组，那么接收这个数组的内容的东西，也必须是一个数组，但C语言的数组名是一个右值，它不能作为左值来接收另一个数组，因此函数返回值不能为数组。

~~~ cpp
int func[5](void);
~~~
func是一个具有5个元素的数组，这个数组的元素都是函数。这也是非法的，因为数组的元素除了类型必须一样外，每个元素所占用的内存空间也必须相同，显然函数是无法达到这个要求的，即使函数的类型一样，但函数所占用的空间通常是不相同的。
## 练习
 作为练习，下面列几个复杂指针声明给读者自己来解析，答案放在第十章里。
~~~ cpp
int (*(*func)[5][6])[7][8];
int (*(*(*func)(int *))[5])(int *);
int (*(*func[7][8][9])(int*))[5];
~~~
## 技巧
实际当中，需要声明一个复杂指针时，如果把整个声明写成上面所示的形式，对程序可读性是一大损害。应该用typedef来对声明逐层分解，增强可读性，例如对于声明：
~~~ cpp
int (*(*func)(int *p))[5];
~~~
可以这样分解：
~~~ cpp
typedef  int (*PARA)[5];
typedef PARA (*func)(int *);
~~~
这样就容易看得多了。

## 答案及typedef的分解方法：
~~~ cpp
int (*(*func)[5][6])[7][8];
~~~
func是一个指向数组的指针，这类数组的元素是一个具有5X6个int元素的二维数组，而这个二维数组的元素又是一个二维数组。
分解如下：
~~~ cpp
typedef int (*PARA)[7][8];
typedef PARA (*func)[5][6];
~~~

~~~ cpp
int (*(*(*func)(int *))[5])(int *);
~~~
func是一个函数指针，这类函数的返回值是一个指向数组的指针，所指向数组的元素也是函数指针，指向的函数具有int*形参，返回值为int
分解如下：
~~~ cpp
typedef int (*PARA1)(int*);
typedef PARA1 (*PARA2)[5];
typedef PARA2 (*func)(int*);
~~~

~~~ cpp
int (*(*func[7][8][9])(int*))[5];
~~~
func是一个数组，这个数组的元素是函数指针，这类函数具有int*的形参，返回值是指向数组的指针，所指向的数组的元素是具有5个int元素的数组。
分解如下：
~~~ cpp
typedef int (*PARA1)[5];
typedef PARA1 (*PARA2)(int*);
typedef PARA2 func[7][8][9];
~~~
# const define enum区别
const一词是英文constant的缩写，设立这个关键字的本意，是希望让它所修饰的对象成为一个常量。
记得在国家间的外交中，有一个经常用到的术语：“从事与身份不符的活动”，这个const恰恰也正从事着这样的活动，呵呵。
C语言可以有三种方法定义一个常量：\#define、const和枚举，但只有枚举才是真正的常量，什么是真正的常量？
真正的常量是没有存储空间的，是一个右值，这意味着通过任何合法的手段也不会被修改，但被const修饰的对象依然是一个左值，尽管这个对象被const限定，笔者仍然至少可以找到三种合法的手段去修改它，而#define所做的只不过是编译期替换而已，只有枚举常量才能真正做到这一点。const实在不应该被命名为const，这会让人们产生误解，它应该命名为readonly或类似的字眼，意即不能通过被const修饰的对象修改它所指向的对象或者它所代表的对象。但在C的世界里把const称为常量早已是普遍的现象，那我们就只好随大流咯，也称之为常量吧，只要知道它实际上不是真正的常量就行了。
第七章曾经讨论过const int \*p;与int \* const p的区别，这两个声明的中文名称常常搞得混乱不堪。第一个声明的const是声明说明符，它修饰p所指向的对象，但p仍然是可变的，这意味着p是一个指向常量的指针，简称常量指针。第二个声明的const是声明符的一部分，它修饰的对象是p，这意味着p是一个常量，而且是一个指针类型的常量，简称指针常量。指针常量又常常被人称为“常指针”或“常指针变量”，常指针变量这个名称有点蹩脚，又常又变的，容易让人摸不着头脑，最好还是不要这样称呼。这里还得再强调一次指针常量与地址常量是不同的，不能把数组名称为指针常量，也不能把指针常量称为地址常量，因为指针常量依然是一个左值，而数组名是一个右值，这里肯定有人会问：“什么？指针常量是一个左值？我没听错吧？”你的确没有听错，C89对于左值是这样定义的：
对象是一个命名的存储区域，左值（lvalue）是引用某个对象的表达式。
换言之，如果一个表达式引用的是一个具有具体存储空间的对象，它就是一个左值！那么既然指针常量是一个左值，为什么却不能给它赋值呢？是因为它受限于赋值表达式的一条规则：赋值表达式的左值不能含有限定词！

为了防止指针指向的常量被修改，C标准对于指针间赋值有一个规定，就是左值必须包含右值的所有限定词。 这就限定了一个指向const对象的指针不能赋值给指向非const对象的指针，但反过来就允许。这个规定初看上去非常合理，但其效用其实只限于一级指针，二级指针间的赋值即使满足规定也不再安全，下面举个例子：
~~~ cpp
const int i=10;
const int **p1;
int *p2;
p1 = &p2;
*p1 = &i;
*p2 = 20;
~~~
现在你会发现，作为常量的i的值被修改了。i的值被修改的关键原因在\*p1=\&i;这一句，\&i是一个指向常量的一级地址，如果没有二级指针p1，受限于上述规定，作为左值接受这个一级地址的指针就必须也是一个指向常量的一级指针，于是就不能进行下一步赋值20的操作。因此，正由于指向const对象的二级指针p1的出现，使得\*p1也是一个指向const的指针，于是\*p1=&i能够合法地运行，常量i的值被修改也就成了一个预想中的结果了。有鉴于此，某些编译器也会限定非const二级指针之间的赋值，规定上面的p1=\&p2也是非法的。

## 第七章介绍声明符的指针部分有一种形式：
\* 类型限定符表opt 指针
这种形式产生了一种比较复杂的带const的指针，例如：
~~~ cpp
const int * const *** const ** const p;
~~~
这是一个会让人头晕目眩的表达式，声明符部分嵌套了九次，如何辨认谁是const，谁不是const呢？一旦明白了其中的原则，其实是非常简单的。第一和最后一个const大家都已经很熟悉的了。对于藏在一堆*号中的const，有一个非常简单的原则：const与左边最后一个声明说明符之间有多少个*号，那么就是多少级指针是const的。例如从右数起第二个const，它与int之间有4个*号，那么p的四级部分就是const的，下面的赋值表达式是非法的：
~~~ cpp
**p = (int *const***)10;
~~~

但下面的赋值是允许的：
~~~ cpp
***p=(int*const**)10;
~~~
从左边数起第二个const，它与int之间有1个*，那么p的一级部分是const的，也就是*****p = (int*const***const*)10;是非法的。

对于一个函数：
~~~ cpp
void func(void);
~~~
我们通常可以定义一个这样的函数指针指向它：
~~~ cpp
void (*p)(void) = func;
~~~
通过p调用func时，通常有两种写法：
p();或者(\*p)();
 围绕这两种写法，当初C89制定的时候曾经有过争论。\(\*p\)\(\);是一种旧式的规定，旧式规定圆括号左边必须具有“函数”类型，如果是指向函数的指针，那么必须加上\*声明符。但C89不再把圆括号的左边限定为“函数”类型，而是一个后缀表达式。那么问题就来了，如果p的值是函数地址，那么\*号就是声明符，但如果p指向的内容是函数地址，\*号就得被看作运算符了。同一种形式会有两种解释，这是一个矛盾。不仅函数调用如此，指向数组的指针也存在这种矛盾。编译器为了处理这种情况得增加代码，效率自然就降低了。争论的最后结果是谁也不能把对方完全说服，于是就干脆两种都支持了。笔者认为应该抛弃旧式的规定，p\(\);这种形式简洁明了，又符合函数的一般形式，何乐而不为？
